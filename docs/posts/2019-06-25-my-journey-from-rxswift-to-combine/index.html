<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8" name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/pure-min.css" integrity="sha384-oAOxQR6DkCoMliIh8yFnu25d7Eq/PHS21PClpwjOTeU2jRSq11vu66rf90/cZr47" crossorigin="anonymous"/><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/grids-responsive-min.css"/><link rel="stylesheet" href="/Pure/styles.css"/><link rel="stylesheet" href="/all.css"/></head><body><div id="layout" class="pure-g"><div class="sidebar pure-u-1 pure-u-md-1-4"><div class="header"><div id="layout" class="pure-g"><div class="pure-u-md-1-1 pure-u-3-4"><h1 class="brand-title">Bitomule's learning shack</h1><h3 class="brand-tagline">My thoughts about iOS, technology or any other thing that comes to my mind.</h3></div></div><div id="layout" class="pure-g"><div class="pure-u-md-1-1"><a href="mailto:bitomule+blog@gmail.com"><i class="fas fa-envelope-open-text l-box social-icon"></i><a class="social-media" href="mailto:bitomule+blog@gmail.com">Email</a></a></div><div class="pure-u-md-1-1"><a href="https://www.linkedin.com/in/davidcolladosela/"><i class="fab fa-linkedin l-box social-icon"></i><a class="social-media" href="https://www.linkedin.com/in/davidcolladosela/">LinkedIn</a></a></div><div class="pure-u-md-1-1"><a href="https://github.com/bitomule"><i class="fab fa-github-square l-box social-icon"></i><a class="social-media" href="https://github.com/bitomule">GitHub</a></a></div><div class="pure-u-md-1-1"><a href="https://twitter.com/Bitomule"><i class="fab fa-twitter-square l-box social-icon"></i><a class="social-media" href="https://twitter.com/Bitomule">Twitter</a></a></div></div></div></div><div class="content pure-u-1 pure-u-md-3-5 pure-u-xl-6-10"><h2 class="post-title"><a href="/posts/2019-06-25-my-journey-from-rxswift-to-combine">My Journey from RxSwift to Combine</a></h2><p class="post-meta">25 de junio de 2019</p><div class="post-tags"><a class="post-category post-category-combine" href="/tags/combine">Combine</a><a class="post-category post-category-ios" href="/tags/ios">iOS</a></div><div class="post-description"><div><h1>My Journey from RxSwift to Combine</h1><p>Some days Ago I decided it was the perfect time to start trying Combine by introducing it into my latest project <a href="https://blog.bitomule.com/kitchenorder/">(The app I made for my father)</a> and this is the story on what issues I’ve found, what I have learned and what I had to fix myself.</p><h2>iOS 13</h2><p>The latest Apple release was the biggest change since Swift and I think it could be even bigger.</p><p>Keep in mind that Combine is only available for &gt;= iOS 13, it’ll grow in the future and right now feels like it’s far from finished. For <a href="https://kitchenorder.app">KitchenOrder</a> it’s ok to make iOS 13 a requirement, but we’ll have to wait years before we can introduce it in other projects.</p><h2>Realm</h2><p>The first bump in the road I found trying to introduce Combine was the usage of <a href="https://github.com/RxSwiftCommunity/RxRealm">RxRealm</a>: an amazing library that adds reactivity to Realm using RxSwift.</p><p>The problem was replacing the amazing job by RxSwift contributors with a Combine based approach. There wasn’t a library doing this task for me so I decided to build my own: “there’s no much difference between RxSwift and Combine, it should be an easy task”, I (wrongly) thought.</p><p>Realm has a nice notification based way to get changes from Realm itself, queries (Results) and single objects and I already had experience with it because I built the same thing for <a href="https://medium.com/@Bitomule/creating-reactiveswiftrealm-part-1-248ac5c721af">ReactiveCocoa</a> some years ago. It works like this:</p><pre><code>     <span class="keyword">let</span> token = collection.<span class="call">observe</span> { changeset <span class="keyword">in</span> ... }
</code></pre><p>If you know a bit about RxSwift it’ll be trivial to transform this into an Observable and there’s only one tricky part you’ll have to consider: <strong>the token</strong>. You have to store that token while the observable is alive and invalidate it once the observable is finished. If you get this wrong, you’ll get no changes because notification is dead before you even receive the first change or it will stay alive forever.</p><p>In RxSwift they used the <strong>Disposable.create</strong> callback that gets called when your observer gets disposed. That’s perfect: your notification life is attached to your observer.</p><p>The problem is that Combine does not work in the same way: you don’t return a Disposable, in fact, when building a Publisher you don’t return anything. There’s not an onDisposed or deinit callback. So... How did I fix it?</p><p>Welcome to handleEvents:</p><pre><code>     <span class="keyword">public func</span> handleEvents(receiveSubscription: ((<span class="type">Subscription</span>) -&gt; <span class="type">Void</span>)? = <span class="keyword">nil</span>, receiveOutput: ((<span class="type">Self</span>.<span class="type">Output</span>) -&gt; <span class="type">Void</span>)? = <span class="keyword">nil</span>, receiveCompletion: ((<span class="type">Subscribers</span>.<span class="type">Completion</span>&lt;<span class="type">Self</span>.<span class="type">Failure</span>&gt;) -&gt; <span class="type">Void</span>)? = <span class="keyword">nil</span>, receiveCancel: (() -&gt; <span class="type">Void</span>)? = <span class="keyword">nil</span>, receiveRequest: ((<span class="type">Subscribers</span>.<span class="type">Demand</span>) -&gt; <span class="type">Void</span>)? = <span class="keyword">nil</span>) -&gt; <span class="type">Publishers</span>.<span class="type">HandleEvents</span>&lt;<span class="type">Self</span>&gt;
</code></pre><p>Nice, isn’t it? (Generics can melt your brain)</p><p>It’s like the do operator on RxSwift. It allows us to execute code when specific events happen. In this case, the events we are interested in are <strong>receiveCompletion</strong> and <strong>receiveCancel</strong>. Those are the 2 cases where we need to invalidate the token so I added the code to my publisher init call:</p><pre><code>     .<span class="call">handleEvents</span>(receiveCompletion: { <span class="keyword">_ in</span>
        token?.<span class="call">invalidate</span>()
    }, receiveCancel: {
        token?.<span class="call">invalidate</span>()
    })
</code></pre><p>But this doesn’t compile. The return type of handleEvents is not AnyPublisher, it’s a completely different type that conforms to Publisher protocol. To get the proper type back we’ve to use <strong>eraseToAnyPublisher()</strong>. Note this method down: if you start using Combine you’ll use it a lot, or at least that was my experience (I hope I’m wrong and there’s a better way to skip it).</p><pre><code>     .<span class="call">handleEvents</span>(receiveCompletion: { <span class="keyword">_ in</span>
        token?.<span class="call">invalidate</span>()
    }, receiveCancel: {
        token?.<span class="call">invalidate</span>()
    })
    .<span class="call">eraseToAnyPublisher</span>()
</code></pre><p>Once I had this solved I started to add new methods to my pod to observe realm, observe a collection, observe a changeset... And I found myself writing the same code again and again, so I extracted it and made it a bit more generic.</p><pre><code>     <span class="keyword">extension</span> <span class="type">Publisher</span> {
        <span class="keyword">func</span> onDispose(<span class="keyword">_</span> onDispose: <span class="keyword">@escaping</span> () -&gt; <span class="type">Void</span>) -&gt; <span class="type">AnyPublisher</span>&lt;<span class="type">Output</span>, <span class="type">Failure</span>&gt; {
            <span class="keyword">return self</span>.<span class="call">handleEvents</span>(receiveCompletion: { <span class="keyword">_ in</span>
                onDispose()
            }, receiveCancel: {
                <span class="call">onDispose</span>()
            }).<span class="call">eraseToAnyPublisher</span>()
        }
    }
</code></pre><p>Now the code was a bit nicer:</p><pre><code>     .<span class="call">onDispose</span> {
        token?.<span class="call">invalidate</span>()
    }
</code></pre><p>So far I had found 2 issues adding Combine to my RxSwift project. One a bit specific of the use case, but I’ve found myself using reaseToAnyPublisher() <strong>A LOT</strong>.</p><h2>DisposeBag</h2><p>This problem may be specific to how you use Combine. In this case it´s replacing RxSwift without any UI binding.</p><p>First, let me tell you how the UI layer works in my app:</p><ul><li>Presenter calls and subscribes to a Publisher</li><li>With each event, it tells the UI to update with x changes</li></ul><p>It’s not exactly the MVVM that seems to fit Combine and SwiftUI better.</p><p>With RxSwift this is not a problem because when you subscribe you can add the returned disposable to a dispose bag. This DisposeBag basically attaches the life of your observable to the DisposeBag instance. If the presenter is released, DisposeBag gets released and all your observers get disposed and released. An amazing job from RxSwift developers but... There’s no equivalent in Combine.</p><p>In Combine, when you execute sink (equivalent to subscribe) you get back a cancellable and is your responsibility to manage it and remember to call cancel on it when you need to cancel that Publisher.</p><p>Now, image the presenter consumes 2 publishers. I have to keep 2 references to the cancellables of those publishers and call cancel on them when my presenter gets released (deinit). If you do the same in all your presenters, It’ll become a mess difficult to keep updated. It’s really easy to forget calling cancel on one of this cancellables and keep an observable alive forever.</p><p>So, another issue, another fix. I created <a href="https://github.com/bitomule/CombineDisposeBag">another public repo</a> with a DisposeBag for Combine. It’s exactly the same behavior you get from RxSwift. You have to create DisposeBag and tell each subscription to get disposed by that DisposeBag you created. It’s really easy to use and makes migrating from RxSwift to Combine a lot easier. Of course, I’ve filled feedback to Apple because It’ll be a lot better if they fixed this kind of rough edges in Combine.</p><p>That’s all so far, please feel free to ask me on twitter <a href="https://twitter.com/Bitomule">@bitomule</a> and create issues or PRs (better) on both repositories <a href="https://github.com/bitomule/CombineRealm">CombineRealm</a> and <a href="https://github.com/bitomule/CombineDisposeBag">CombineDisposeBag</a>. I’ll keep learning and trying to share what I’ve learned.</p></div></div></div><div class="footer pure-u-1"><div class="pure-u-1">© 2020 Bitomule's learning shack</div><div class="pure-u-1">Generated using <a href="https://github.com/johnsundell/publish">Publish</a>. Written in Swift</div><div class="pure-u-1"><a href="/feed.rss">RSS feed</a></div></div></div></body></html>